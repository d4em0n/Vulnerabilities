
## Oracle VirtualBox OHCI Use-After-Free

### Revision record

| Date       | Revision Version | Change Description     | Author           |
| ---------- | ---------------- | ---------------------- | ---------------- |
| 07/10/2019 | 1.0              | Vulnerability Analysis | Add of STAR Labs |

### Affected Software

Oracle VirtualBox 6.0.12 revision r133076 and prior versions.

### Severity of the bug

High

### Description of the vulnerability

**OHCI (Open Host Controller Interface for USB)** is the default **USB Controller** for both Windows and Linux guest. The **URB (USB Request Block)** processing has a vulnerability that allows an attacker with root/administrator privileges in the guest OS to execute arbitrary code in the host OS.

### Technical Details

#### The Vulnerability

When the emulated device service a transport descriptor, it'll allocate and initialize a new URB then submit it:

*VirtualBox-6.0.12\src\VBox\Devices\USB\DevOHCI.cpp:3027*

~~~c++
static bool ohciR3ServiceTd(POHCI pThis, VUSBXFERTYPE enmType, PCOHCIED pEd, uint32_t EdAddr, uint32_t TdAddr,
                            uint32_t *pNextTdAddr, const char *pszListName)
{

...    

    /*
     * Allocate and initialize a new URB.
     */
    PVUSBURB pUrb = VUSBIRhNewUrb(pThis->RootHub.pIRhConn, pEd->hwinfo & ED_HWINFO_FUNCTION, NULL,
                                  enmType, enmDir, Buf.cbTotal, 1, NULL);
    if (!pUrb)
        return false;                   /* retry later... */

...

    /*
     * Submit the URB.
     */
    ohciR3InFlightAdd(pThis, TdAddr, pUrb);
    Log(("%s: ohciR3ServiceTd: submitting TdAddr=%#010x EdAddr=%#010x cbData=%#x\n",
         pUrb->pszDesc, TdAddr, EdAddr, pUrb->cbData));

    ohciR3Unlock(pThis);
    int rc = VUSBIRhSubmitUrb(pThis->RootHub.pIRhConn, pUrb, &pThis->RootHub.Led);
    ohciR3Lock(pThis);
    if (RT_SUCCESS(rc))
        return true;

...    
    
}
~~~

Dig into the implement of `VUSBIRhSubmitUrb()`:

*VirtualBox-6.0.12\include\VBox\vusb.h:884*

~~~c++
DECLINLINE(int) VUSBIRhSubmitUrb(PVUSBIROOTHUBCONNECTOR pInterface, PVUSBURB pUrb, struct PDMLED *pLed)
{
    return pInterface->pfnSubmitUrb(pInterface, pUrb, pLed);
}
~~~

*VirtualBox-6.0.12\src\VBox\Devices\USB\DrvVUSBRootHub.cpp:1339*

~~~c++
pThis->IRhConnector.pfnSubmitUrb                  = vusbRhSubmitUrb;
~~~

*VirtualBox-6.0.12\src\VBox\Devices\USB\DrvVUSBRootHub.cpp:661*

~~~c++
static DECLCALLBACK(int) vusbRhSubmitUrb(PVUSBIROOTHUBCONNECTOR pInterface, PVUSBURB pUrb, PPDMLED pLed)
{

...    
    
    /*
     * The device was resolved when we allocated the URB.
     * Submit it to the device if we found it, if not fail with device-not-ready.
     */
    int rc;
    if (   pUrb->pVUsb->pDev
        && pUrb->pVUsb->pDev->pUsbIns)
    {
        switch (pUrb->enmDir)
        {
            case VUSBDIRECTION_IN:
                pLed->Asserted.s.fReading = pLed->Actual.s.fReading = 1;
                rc = vusbUrbSubmit(pUrb);
                pLed->Actual.s.fReading = 0;
                break;
            case VUSBDIRECTION_OUT:
                pLed->Asserted.s.fWriting = pLed->Actual.s.fWriting = 1;
                rc = vusbUrbSubmit(pUrb);
                pLed->Actual.s.fWriting = 0;
                break;
            default:
                rc = vusbUrbSubmit(pUrb);
                break;
        }

        if (RT_FAILURE(rc))
        {
            LogFlow(("vusbRhSubmitUrb: freeing pUrb=%p\n", pUrb));
            pUrb->pVUsb->pfnFree(pUrb);
        }
    }

...    
    
    return rc;
}
~~~

If the `vusbUrbSubmit()` function return failure, the URB will be freed with:

~~~c++
pUrb->pVUsb->pfnFree(pUrb);
~~~

Then the function `vusbRhSubmitUrb()` also return failure.

*VirtualBox-6.0.12\src\VBox\Devices\USB\DevOHCI.cpp:2956*

~~~c++
static bool ohciR3ServiceTd(POHCI pThis, VUSBXFERTYPE enmType, PCOHCIED pEd, uint32_t EdAddr, uint32_t TdAddr,
                            uint32_t *pNextTdAddr, const char *pszListName)
{

...    
    
    int rc = VUSBIRhSubmitUrb(pThis->RootHub.pIRhConn, pUrb, &pThis->RootHub.Led);
    ohciR3Lock(pThis);
    if (RT_SUCCESS(rc))
        return true;

    /* Failure cleanup. Can happen if we're still resetting the device or out of resources. */
    Log(("ohciR3ServiceTd: failed submitting TdAddr=%#010x EdAddr=%#010x pUrb=%p!!\n",
         TdAddr, EdAddr, pUrb));
    VUSBIRhFreeUrb(pThis->RootHub.pIRhConn, pUrb);
    ohciR3InFlightRemove(pThis, TdAddr);
    return false;
}
~~~

If the URB is failed to submit with `VUSBIRhSubmitUrb()`, it'll be freed with `VUSBIRhFreeUrb()`:

*VirtualBox-6.0.12\include\VBox\vusb.h:2956*

~~~c++
DECLINLINE(int) VUSBIRhFreeUrb(PVUSBIROOTHUBCONNECTOR pInterface, PVUSBURB pUrb)
{
    return pInterface->pfnFreeUrb(pInterface, pUrb);
}
~~~

*VirtualBox-6.0.12\src\VBox\Devices\USB\DrvVUSBRootHub.cpp:1338*

~~~c++
pThis->IRhConnector.pfnFreeUrb                    = vusbRhConnFreeUrb;
~~~

*VirtualBox-6.0.12\src\VBox\Devices\USB\DrvVUSBRootHub.cpp:652*

~~~c++
static DECLCALLBACK(int) vusbRhConnFreeUrb(PVUSBIROOTHUBCONNECTOR pInterface, PVUSBURB pUrb)
{
    RT_NOREF(pInterface);
    pUrb->pVUsb->pfnFree(pUrb);
    return VINF_SUCCESS;
}
~~~

So an URB which is failed to submit will be freed twice, the first time in `vusbRhSubmitUrb()` and the second is in `ohciR3ServiceTd()`. The callback `pUrb->pVUsb->pfnFree()` is initialized at:

*VirtualBox-6.0.12\src\VBox\Devices\USB\DrvVUSBRootHub.cpp:392*

~~~c++
static PVUSBURB vusbRhNewUrb(PVUSBROOTHUB pRh, uint8_t DstAddress, PVUSBDEV pDev, VUSBXFERTYPE enmType,
                             VUSBDIRECTION enmDir, uint32_t cbData, uint32_t cTds, const char *pszTag)
{

...    
    
    if (RT_LIKELY(pUrb))
    {
        pUrb->pVUsb->pvFreeCtx = pRh;
        pUrb->pVUsb->pfnFree   = vusbRhFreeUrb;
        pUrb->DstAddress       = DstAddress;
        pUrb->pVUsb->pDev      = pDev;


...        

    return pUrb;
}
~~~

*VirtualBox-6.0.12\src\VBox\Devices\USB\DrvVUSBRootHub.cpp:356*

~~~c++
static DECLCALLBACK(void) vusbRhFreeUrb(PVUSBURB pUrb)
{
    /*
     * Assert sanity.
     */
    vusbUrbAssert(pUrb);
    PVUSBROOTHUB pRh = (PVUSBROOTHUB)pUrb->pVUsb->pvFreeCtx;
    Assert(pRh);

    Assert(pUrb->enmState != VUSBURBSTATE_FREE);

    /*
     * Free the URB description (logging builds only).
     */
    if (pUrb->pszDesc)
    {
        RTStrFree(pUrb->pszDesc);
        pUrb->pszDesc = NULL;
    }

    /* The URB comes from the roothub if there is no device (invalid address). */
    if (pUrb->pVUsb->pDev)
    {
        PVUSBDEV pDev = pUrb->pVUsb->pDev;

        vusbUrbPoolFree(&pUrb->pVUsb->pDev->UrbPool, pUrb);
        vusbDevRelease(pDev);
    }
    else
        vusbUrbPoolFree(&pRh->Hub.Dev.UrbPool, pUrb);
}
~~~

The `vusbRhFreeUrb()` call back will free the URB with `vusbUrbPoolFree()` which will append the current URB to the free URB list:

*VirtualBox-6.0.12\src\VBox\Devices\USB\VUSBUrbPool.cpp:222*

~~~c++
DECLHIDDEN(void) vusbUrbPoolFree(PVUSBURBPOOL pUrbPool, PVUSBURB pUrb)
{
    PVUSBURBHDR pHdr = VUSBURBPOOL_URB_2_URBHDR(pUrb);

    /* URBs which aged too much because they are too big are freed. */
    if (pHdr->cAge == VUSBURB_AGE_MAX)
    {
        ASMAtomicDecU32(&pUrbPool->cUrbsInPool);
        RTMemFree(pHdr);
    }
    else
    {
        /* Put it into the list of free URBs. */
        VUSBXFERTYPE enmType = pUrb->enmType;
        AssertReturnVoid((size_t)enmType < RT_ELEMENTS(pUrbPool->aLstFreeUrbs));
        RTCritSectEnter(&pUrbPool->CritSectPool);
        pUrb->enmState = VUSBURBSTATE_FREE;
        RTListAppend(&pUrbPool->aLstFreeUrbs[enmType], &pHdr->NdFree);
        RTCritSectLeave(&pUrbPool->CritSectPool);
    }
}
~~~

Then the USB Device is released with `vusbDevRelease()`

*VirtualBox-6.0.12\src\VBox\Devices\USB\VUSBInternal.h:727*

~~~c++
DECLINLINE(uint32_t) vusbDevRelease(PVUSBDEV pThis)
{
    AssertPtrReturn(pThis, UINT32_MAX);

    uint32_t cRefs = ASMAtomicDecU32(&pThis->cRefs);
    AssertMsg(cRefs < _1M, ("%#x %p\n", cRefs, pThis));
    if (cRefs == 0)
        vusbDevDestroy(pThis);
    return cRefs;
}
~~~

`vusbDevRelease()` will decrease the reference count of the device, if there are no references left to it, the USB device will be destroyed by `vusbDevDestroy()`

*VirtualBox-6.0.12\src\VBox\Devices\USB\VUSBDevice.cpp:1268*

~~~c++
void vusbDevDestroy(PVUSBDEV pDev)
{
    LogFlow(("vusbDevDestroy: pDev=%p[%s] enmState=%d\n", pDev, pDev->pUsbIns->pszName, pDev->enmState));

    RTMemFree(pDev->paIfStates);
    TMR3TimerDestroy(pDev->pResetTimer);
    pDev->pResetTimer = NULL;
    for (unsigned i = 0; i < RT_ELEMENTS(pDev->aPipes); i++)
    {
        Assert(pDev->aPipes[i].pCtrl == NULL);
        RTCritSectDelete(&pDev->aPipes[i].CritSectCtrl);
    }

    if (pDev->hSniffer != VUSBSNIFFER_NIL)
        VUSBSnifferDestroy(pDev->hSniffer);

    vusbUrbPoolDestroy(&pDev->UrbPool);

    RTCritSectDelete(&pDev->CritSectAsyncUrbs);
    /* Not using vusbDevSetState() deliberately here because it would assert on the state. */
    pDev->enmState = VUSB_DEVICE_STATE_DESTROYED;
    pDev->pUsbIns->pvVUsbDev2 = NULL;
    RTMemFree(pDev);
}
~~~

In normal conditions, the USB Device Object is initialized with the reference count is `1`, allocate new URB also increases the count by `1`. If the submitting is failed, it should have been decreased once then the last reference will only be freed when the USB root hub is detached while the OS is shutting down. 

The URB double free could make the USB Device Object be freed while the guest OS is still running.

#### The Exploitation

##### Interact With The OHCI Device

Like many other devices, OHCI also uses **MMIO (Memory-Mapped I/O)** method to perform input/output between the device and the guest's CPU. The MMIO handlers are registered with `PDMDevHlpMMIORegister()`:

*VirtualBox-6.0.12\src\VBox\Devices\USB\DevOHCI.cpp:5467*

~~~c++
static DECLCALLBACK(int) ohciR3Map(PPDMDEVINS pDevIns, PPDMPCIDEV pPciDev, uint32_t iRegion,
                                   RTGCPHYS GCPhysAddress, RTGCPHYS cb, PCIADDRESSSPACE enmType)
{
    RT_NOREF(iRegion, enmType);
    POHCI pThis = (POHCI)pPciDev;
    int rc = PDMDevHlpMMIORegister(pDevIns, GCPhysAddress, cb, NULL /*pvUser*/,
                                   IOMMMIO_FLAGS_READ_DWORD | IOMMMIO_FLAGS_WRITE_DWORD_ZEROED
                                   | IOMMMIO_FLAGS_DBGSTOP_ON_COMPLICATED_WRITE,
                                   ohciMmioWrite, ohciMmioRead, "USB OHCI");
    if (RT_FAILURE(rc))
        return rc;

    if (pThis->fRZEnabled)
    {
        rc = PDMDevHlpMMIORegisterRC(pDevIns, GCPhysAddress, cb, NIL_RTRCPTR /*pvUser*/, "ohciMmioWrite", "ohciMmioRead");
        if (RT_FAILURE(rc))
            return rc;

        rc = PDMDevHlpMMIORegisterR0(pDevIns, GCPhysAddress, cb, NIL_RTR0PTR /*pvUser*/, "ohciMmioWrite", "ohciMmioRead");
        if (RT_FAILURE(rc))
            return rc;
    }

    pThis->MMIOBase = GCPhysAddress;
    return VINF_SUCCESS;
}
~~~

`ohciMmioWrite()`/`ohciMmioRead()` are the handlers for MMIO write/read access. 

> While debugging some VirtualBox devices, I'm faced with a problem like setting memory breakpoints and see the values are changing, but for some reason, breakpoints aren't hitting. This caused by the kernel module `VboxDD.r0` modify the memory in kernel mode then a debugger in user mode can't catch this. You may want to disable the `pThis->fRZEnabled` flag to disable the kernel module.

The read/write access to the MMIO is actually read/write access to the OHCI device registers, the register index is the index of the read/write operation to the physical address of the MMIO in the guest OS.

*VirtualBox-6.0.12\src\VBox\Devices\USB\DevOHCI.cpp:5435*

~~~c++
PDMBOTHCBDECL(int) ohciMmioWrite(PPDMDEVINS pDevIns, void *pvUser, RTGCPHYS GCPhysAddr, void const *pv, unsigned cb)
{
    POHCI pThis = PDMINS_2_DATA(pDevIns, POHCI);
    RT_NOREF1(pvUser);

    /* Paranoia: Assert that IOMMMIO_FLAGS_WRITE_DWORD_ZEROED works. */
    AssertReturn(cb == sizeof(uint32_t), VERR_INTERNAL_ERROR_3);
    AssertReturn(!(GCPhysAddr & 0x3), VERR_INTERNAL_ERROR_4);

    /*
     * Validate the register and call the read operator.
     */
    int rc;
    const uint32_t iReg = (GCPhysAddr - pThis->MMIOBase) >> 2;
    if (iReg < NUM_OP_REGS(pThis))
    {
        const OHCIOPREG *pReg = &g_aOpRegs[iReg];
        rc = pReg->pfnWrite(pThis, iReg, *(uint32_t const *)pv);
    }
    else
    {
        Log(("ohci: Trying to write to register %u/%u!!!\n", iReg, NUM_OP_REGS(pThis)));
        rc = VINF_SUCCESS;
    }
    return rc;
}
~~~

*VirtualBox-6.0.12\src\VBox\Devices\USB\DevOHCI.cpp:5404*

~~~c++
PDMBOTHCBDECL(int) ohciMmioRead(PPDMDEVINS pDevIns, void *pvUser, RTGCPHYS GCPhysAddr, void *pv, unsigned cb)
{
    POHCI pThis = PDMINS_2_DATA(pDevIns, POHCI);
    RT_NOREF1(pvUser);

    /* Paranoia: Assert that IOMMMIO_FLAGS_READ_DWORD works. */
    AssertReturn(cb == sizeof(uint32_t), VERR_INTERNAL_ERROR_3);
    AssertReturn(!(GCPhysAddr & 0x3), VERR_INTERNAL_ERROR_4);

    /*
     * Validate the register and call the read operator.
     */
    int rc;
    const uint32_t iReg = (GCPhysAddr - pThis->MMIOBase) >> 2;
    if (iReg < NUM_OP_REGS(pThis))
    {
        const OHCIOPREG *pReg = &g_aOpRegs[iReg];
        rc = pReg->pfnRead(pThis, iReg, (uint32_t *)pv);
    }
    else
    {
        Log(("ohci: Trying to read register %u/%u!!!\n", iReg, NUM_OP_REGS(pThis)));
        rc = VINF_IOM_MMIO_UNUSED_FF;
    }
    return rc;
}
~~~

There are 36 registers in the OHCI device:

*VirtualBox-6.0.12\src\VBox\Devices\USB\DevOHCI.cpp:5349*

~~~c++
static const OHCIOPREG g_aOpRegs[] =
{
    { "HcRevision",          HcRevision_r,           HcRevision_w },            /*  0 */
    { "HcControl",           HcControl_r,            HcControl_w },             /*  1 */
    { "HcCommandStatus",     HcCommandStatus_r,      HcCommandStatus_w },       /*  2 */
    { "HcInterruptStatus",   HcInterruptStatus_r,    HcInterruptStatus_w },     /*  3 */
    { "HcInterruptEnable",   HcInterruptEnable_r,    HcInterruptEnable_w },     /*  4 */
    { "HcInterruptDisable",  HcInterruptDisable_r,   HcInterruptDisable_w },    /*  5 */
    { "HcHCCA",              HcHCCA_r,               HcHCCA_w },                /*  6 */
    { "HcPeriodCurrentED",   HcPeriodCurrentED_r,    HcPeriodCurrentED_w },     /*  7 */
    { "HcControlHeadED",     HcControlHeadED_r,      HcControlHeadED_w },       /*  8 */
    { "HcControlCurrentED",  HcControlCurrentED_r,   HcControlCurrentED_w },    /*  9 */
    { "HcBulkHeadED",        HcBulkHeadED_r,         HcBulkHeadED_w },          /* 10 */
    { "HcBulkCurrentED",     HcBulkCurrentED_r,      HcBulkCurrentED_w },       /* 11 */
    { "HcDoneHead",          HcDoneHead_r,           HcDoneHead_w },            /* 12 */
    { "HcFmInterval",        HcFmInterval_r,         HcFmInterval_w },          /* 13 */
    { "HcFmRemaining",       HcFmRemaining_r,        HcFmRemaining_w },         /* 14 */
    { "HcFmNumber",          HcFmNumber_r,           HcFmNumber_w },            /* 15 */
    { "HcPeriodicStart",     HcPeriodicStart_r,      HcPeriodicStart_w },       /* 16 */
    { "HcLSThreshold",       HcLSThreshold_r,        HcLSThreshold_w },         /* 17 */
    { "HcRhDescriptorA",     HcRhDescriptorA_r,      HcRhDescriptorA_w },       /* 18 */
    { "HcRhDescriptorB",     HcRhDescriptorB_r,      HcRhDescriptorB_w },       /* 19 */
    { "HcRhStatus",          HcRhStatus_r,           HcRhStatus_w },            /* 20 */

    /* The number of port status register depends on the definition
     * of OHCI_NDP_MAX macro
     */
    { "HcRhPortStatus[0]",   HcRhPortStatus_r,       HcRhPortStatus_w },        /* 21 */
    { "HcRhPortStatus[1]",   HcRhPortStatus_r,       HcRhPortStatus_w },        /* 22 */
    { "HcRhPortStatus[2]",   HcRhPortStatus_r,       HcRhPortStatus_w },        /* 23 */
    { "HcRhPortStatus[3]",   HcRhPortStatus_r,       HcRhPortStatus_w },        /* 24 */
    { "HcRhPortStatus[4]",   HcRhPortStatus_r,       HcRhPortStatus_w },        /* 25 */
    { "HcRhPortStatus[5]",   HcRhPortStatus_r,       HcRhPortStatus_w },        /* 26 */
    { "HcRhPortStatus[6]",   HcRhPortStatus_r,       HcRhPortStatus_w },        /* 27 */
    { "HcRhPortStatus[7]",   HcRhPortStatus_r,       HcRhPortStatus_w },        /* 28 */
    { "HcRhPortStatus[8]",   HcRhPortStatus_r,       HcRhPortStatus_w },        /* 29 */
    { "HcRhPortStatus[9]",   HcRhPortStatus_r,       HcRhPortStatus_w },        /* 30 */
    { "HcRhPortStatus[10]",  HcRhPortStatus_r,       HcRhPortStatus_w },        /* 31 */
    { "HcRhPortStatus[11]",  HcRhPortStatus_r,       HcRhPortStatus_w },        /* 32 */
    { "HcRhPortStatus[12]",  HcRhPortStatus_r,       HcRhPortStatus_w },        /* 33 */
    { "HcRhPortStatus[13]",  HcRhPortStatus_r,       HcRhPortStatus_w },        /* 34 */
    { "HcRhPortStatus[14]",  HcRhPortStatus_r,       HcRhPortStatus_w },        /* 35 */
};
~~~

The first column is the register's name, the next columns are the correlative read/write handlers.

##### Trigger The URB Double Free

When the guest OS is booting up, it'll transitions the OHCI state to `OHCI_USB_OPERATIONAL` by setting the `HcControl` register value. In the `OHCI_USB_OPERATIONAL` state, the `ohciR3BusStart()` function starts the period frame processing thread then the thread worker will start the frame process routine each frame period:

The frame processing routine is defined at:

*VirtualBox-6.0.12\src\VBox\Devices\USB\DevOHCI.cpp:4078*

~~~c++
static void ohciR3StartOfFrame(POHCI pThis)
{
# ifdef LOG_ENABLED
    const uint32_t status_old = pThis->status;
# endif

    /*
     * Update HcFmRemaining.FRT and update start of frame time.
     */
    pThis->frt = pThis->fit;
    pThis->SofTime += pThis->cTicksPerFrame;

    /*
     * Check that the HCCA address isn't bogus. Linux 2.4.x is known to start
     * the bus with a hcca of 0 to work around problem with a specific controller.
     */
    bool fValidHCCA = !(    pThis->hcca >= OHCI_HCCA_MASK
                        ||  pThis->hcca < ~OHCI_HCCA_MASK);

# if 1
    /*
     * Update the HCCA.
     * Should be done after SOF but before HC read first ED in this frame.
     */
    if (fValidHCCA)
        ohciR3UpdateHCCA(pThis);
# endif

    /* "After writing to HCCA, HC will set SF in HcInterruptStatus" - guest isn't executing, so ignore the order! */
    ohciR3SetInterrupt(pThis, OHCI_INTR_START_OF_FRAME);

    if (pThis->fno)
    {
        ohciR3SetInterrupt(pThis, OHCI_INTR_FRAMENUMBER_OVERFLOW);
        pThis->fno = 0;
    }

    /* If the HCCA address is invalid, we're quitting here to avoid doing something which cannot be reported to the HCD. */
    if (!fValidHCCA)
    {
        Log(("ohciR3StartOfFrame: skipping hcca part because hcca=%RX32 (our 'valid' range: %RX32-%RX32)\n",
             pThis->hcca, ~OHCI_HCCA_MASK, OHCI_HCCA_MASK));
        return;
    }

    /*
     * Periodic EPs.
     */
    if (pThis->ctl & OHCI_CTL_PLE)
        ohciR3ServicePeriodicList(pThis);

    /*
     * Control EPs.
     */
    if (    (pThis->ctl & OHCI_CTL_CLE)
        &&  (pThis->status & OHCI_STATUS_CLF) )
        ohciR3ServiceCtrlList(pThis);

    /*
     * Bulk EPs.
     */
    if (    (pThis->ctl & OHCI_CTL_BLE)
        &&  (pThis->status & OHCI_STATUS_BLF))
        ohciR3ServiceBulkList(pThis);
    else if ((pThis->status & OHCI_STATUS_BLF)
        &&    pThis->fBulkNeedsCleaning)
        ohciR3UndoBulkList(pThis);    /* If list disabled but not empty, abort endpoints. */


...    
    
}
~~~

The three function `ohciR3ServicePeriodicList()`, `ohciR3ServiceCtrlList()` and `ohciR3ServiceBulkList()` will call to `VUSBIRhNewUrb()` and `VUSBIRhSubmitUrb()` later, so as to submit an URB:

- Set the `HcHCCA` (Host Controller Communication Area) register to a valid physical address.
- For periodic endpoints:
  - Toggle on `OHCI_CTL_PLE` (Periodic List Enable) bit in `HcControl` register
- For nonperiodic endpoints:
  - Control List
    - Toggle on `OHCI_CTL_CLE` (Control List Enable) bit in `HcControl` register
    - Toggle on `OHCI_STATUS_CLF` (Control List Filled) bit in `HcCommandStatus` register
  - Bulk List:
    - Toggle on `OHCI_CTL_BLE` (Bulk List Enable) bit in `HcControl` register
    - Toggle on `OHCI_STATUS_BLF` (Bulk List Filled) bit in `HcCommandStatus` register

In order to trigger the URB double free, we need to make the URB submit routine return failure:

*VirtualBox-6.0.12\src\VBox\Devices\USB\VUSBUrb.cpp:1091*

~~~c++
int vusbUrbSubmit(PVUSBURB pUrb)
{

...    

    /*
     * Check that the device is in a valid state.
     */
    const VUSBDEVICESTATE enmState = vusbDevGetState(pDev);
    if (enmState == VUSB_DEVICE_STATE_RESET)
    {
        LogRel(("VUSB: %s: power off ignored, the device is resetting!\n", pDev->pUsbIns->pszName));
        pUrb->enmStatus = VUSBSTATUS_DNR;
        /* This will postpone the TDs until we're done with the resetting. */
        return VERR_VUSB_DEVICE_IS_RESETTING;
    }

...
    
    if (pUrb->EndPt >= VUSB_PIPE_MAX)
    {
        Log(("%s: pDev=%p[%s]: SUBMIT: ep %i >= %i!!!\n", pUrb->pszDesc, pDev, pDev->pUsbIns->pszName, pUrb->EndPt, VUSB_PIPE_MAX));
        return vusbUrbSubmitHardError(pUrb);
    }

...    
    
    if (!pEndPtDesc)
    {
        Log(("%s: pDev=%p[%s]: SUBMIT: no endpoint!!! dir=%s e=%i\n",
             pUrb->pszDesc, pDev, pDev->pUsbIns->pszName, vusbUrbDirName(pUrb->enmDir), pUrb->EndPt));
        return vusbUrbSubmitHardError(pUrb);
    }

...
    
    pUrb->enmState = VUSBURBSTATE_IN_FLIGHT;
    switch (pUrb->enmType)
    {
        case VUSBXFERTYPE_CTRL:
            rc = vusbUrbSubmitCtrl(pUrb);
            break;
        case VUSBXFERTYPE_BULK:
            rc = vusbUrbSubmitBulk(pUrb);
            break;
        case VUSBXFERTYPE_INTR:
            rc = vusbUrbSubmitInterrupt(pUrb);
            break;
        case VUSBXFERTYPE_ISOC:
            rc = vusbUrbSubmitIsochronous(pUrb);
            break;
        default:
            AssertMsgFailed(("Unexpected pUrb type %d\n", pUrb->enmType));
            return vusbUrbSubmitHardError(pUrb);
    }

...    
    
    else if (   RT_FAILURE(rc)
             && !ASMAtomicReadU32(&pDev->aPipes[pUrb->EndPt].async)
             /* && pUrb->enmType == VUSBXFERTYPE_BULK ?? */
             && !vusbUrbErrorRh(pUrb))
    {
        /* don't retry it anymore. */
        pUrb->enmState = VUSBURBSTATE_REAPED;
        pUrb->enmStatus = VUSBSTATUS_CRC;
        vusbUrbCompletionRh(pUrb);
        return VINF_SUCCESS;
    }

    return rc;
}
~~~

`vusbUrbSubmitHardError()` always return `VINF_SUCCESS`

~~~c++
int vusbUrbSubmitHardError(PVUSBURB pUrb)
{
    /* FIXME: Find out the correct return code from the spec */
    pUrb->enmState = VUSBURBSTATE_REAPED;
    pUrb->enmStatus = VUSBSTATUS_DNR;
    vusbUrbCompletionRh(pUrb);
    return VINF_SUCCESS;
}
~~~

So the easiest way to make an URB submitting return failure is to do it while the device is resetting:

*VirtualBox-6.0.12\src\VBox\Devices\USB\VUSBUrb.cpp:1091*

~~~c++
int vusbUrbSubmit(PVUSBURB pUrb)
{
    vusbUrbAssert(pUrb);
    Assert(pUrb->enmState == VUSBURBSTATE_ALLOCATED);
    PVUSBDEV pDev = pUrb->pVUsb->pDev;
    PVUSBPIPE pPipe = NULL;
    Assert(pDev);

    /*
     * Check that the device is in a valid state.
     */
    const VUSBDEVICESTATE enmState = vusbDevGetState(pDev);
    if (enmState == VUSB_DEVICE_STATE_RESET)
    {
        LogRel(("VUSB: %s: power off ignored, the device is resetting!\n", pDev->pUsbIns->pszName));
        pUrb->enmStatus = VUSBSTATUS_DNR;
        /* This will postpone the TDs until we're done with the resetting. */
        return VERR_VUSB_DEVICE_IS_RESETTING;
    }
    
...
    
}    
~~~

We can reset the USB device by setting the `HcRhPortStatus[0]` register with `OHCI_PORT_PRS` bit on:

*VirtualBox-6.0.12\src\VBox\Devices\USB\DevOHCI.cpp:5238*

~~~c++
static int HcRhPortStatus_w(POHCI pThis, uint32_t iReg, uint32_t val)
{

...    
    
    if (val & OHCI_PORT_PRS)
    {
        if (ohciR3RhPortSetIfConnected(&pThis->RootHub, i, val & OHCI_PORT_PRS))
        {
            PVM pVM = PDMDevHlpGetVM(pThis->CTX_SUFF(pDevIns));
            p->fReg &= ~OHCI_PORT_PRSC;
            VUSBIDevReset(p->pDev, false /* don't reset on linux */, ohciR3PortResetDone, pThis, pVM);
        }
        else if (p->fReg & OHCI_PORT_PRS)
        {
            /* the guest is getting impatient. */
            Log2(("HcRhPortStatus_w(): port %u: Impatient guest!\n", i));
            RTThreadYield();
        }
    }

...    
    
}
~~~

`VUSBIDevReset()` function will set the device state to `VUSB_DEVICE_STATE_RESET` and the `ohciR3PortResetDone()` callback will restore the state back to `VUSB_DEVICE_STATE_DEFAULT`. In my observation, this process takes about 100ms and we don't need more than that to submit an URB within the time period.

##### Exploit The Use-After-Free

###### The Tricky Information Leak

We can use the address `0x10000000` as the *leaked* address from the host process, the details can be found [here](https://starlabs.sg/blog/2020/04/adventures-in-hypervisor-oracle-virtualbox-research/) (in the Exploit Primitives part).

###### Leverage The Freed Object

The USB Device Object contains a pointer to a pool of free URBs for faster allocation, a new allocated URB will take one from that pool, I decide to replace the free URBs pool pointer with the *leaked* address `0x10000000`. By filling the Video Ram in the guest OS with fake free URBs pools, we can make the URB allocating return an URB with its address inside the Video RAM. A new URB is initialized at:

*VirtualBox-6.0.12\src\VBox\Devices\USB\DrvVUSBRootHub.cpp:392*

~~~c++
static PVUSBURB vusbRhNewUrb(PVUSBROOTHUB pRh, uint8_t DstAddress, PVUSBDEV pDev, VUSBXFERTYPE enmType,
                             VUSBDIRECTION enmDir, uint32_t cbData, uint32_t cTds, const char *pszTag)
{

...    

    PVUSBURB pUrb = vusbUrbPoolAlloc(pUrbPool, enmType, enmDir, cbData,
                                     pRh->cbHci, pRh->cbHciTd, cTds);
    if (RT_LIKELY(pUrb))
    {
        pUrb->pVUsb->pvFreeCtx = pRh;
        pUrb->pVUsb->pfnFree   = vusbRhFreeUrb;
        pUrb->DstAddress       = DstAddress;
        pUrb->pVUsb->pDev      = pDev;
        
...  

}    
~~~

By scanning the Video Ram buffer inside the guest after submitted an URB, we may found the address of the freed object `pDev` and `vusbRhFreeUrb()` address from the host module `VBoxDD.dll` . We know the offset of those addresses in the URB object structure, we also know where is it in the guest memory, then we can calculate exactly the address of the Video Ram buffer in the host process. With the Video Ram base address in the host, we can figure out the address of the RWX page, its size is 8MB and very near to the Video Ram buffer in the memory layout (unfortunately for us, the recompiler module has been removed since VirtualBox 6.1.0). 

The free URBs pool also has an unlink routine to remove a node from the list:

*VirtualBox-6.0.12\src\VBox\Devices\USB\VUSBUrbPool.cpp:116*

~~~c++
DECLHIDDEN(PVUSBURB) vusbUrbPoolAlloc(PVUSBURBPOOL pUrbPool, VUSBXFERTYPE enmType,
                                      VUSBDIRECTION enmDir, size_t cbData, size_t cbHci,
                                      size_t cbHciTd, unsigned cTds)
{

...    
    
    RTListForEachSafe(&pUrbPool->aLstFreeUrbs[enmType], pIt, pItNext, VUSBURBHDR, NdFree)
    {
        if (pIt->cbAllocated >= cbMem)
        {
            RTListNodeRemove(&pIt->NdFree);

...            
            
}
~~~

*VirtualBox-6.0.12\include\iprt\list.h:153*

~~~c++
DECLINLINE(void) RTListNodeRemove(PRTLISTNODE pNode)
{
    PRTLISTNODE pPrev = pNode->pPrev;
    PRTLISTNODE pNext = pNode->pNext;

    pPrev->pNext = pNext;
    pNext->pPrev = pPrev;

    /* poison */
    pNode->pNext = NULL;
    pNode->pPrev = NULL;
}
~~~

Controlling the `pNode ` struct inside the fake free URBs pool gives us an arbitrary write primitive. The remaining work is quite simple, use the arbitrary write to:

- Write our shellcode to the RWX page
- Overwrite the USB Device Object submit URB callback function pointer with the address of the RWX page
- Submit another URB to execute the shellcode

That's it.

### The Patch

- CVE-2020-2674

- https://www.virtualbox.org/changeset/82661/vbox/trunk/src/VBox/Devices/USB/DevOHCI.cpp
